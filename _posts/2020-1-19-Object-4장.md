---
layout: post
title: 04 설계 품질과 트레이드오프
---

- 객체지향 설계 = 역할, 책임, 협력

- 협력 : 애플리케이션 기능구현을 위해 메시지를 주고 받는 객체들의 상호작용
- 책임 : 객체가 다른 객체와 협력하기 위해 수행하는 행동
- 역할 : 대체 가능한 책임의 집합
  - 책임 주도 설계
    - 이 중 책임이 제일 중요 : 적절하게 할당되지 않으면 원활한 협력도 기대 x, 역할도 협력과 조화 x
- 올바른 객체지향 설계 : 낮은 결합도, 높은 응집도, 올바른 책임 할당

## 데이터 중심의 영화 예매 시스템
- 객체지향 설계는 두 가지 방법을 이용해서 시스템 객체로 분리 가능
  - 상태를 분활의 중심축 사용 : 데이터 중심
  - 책임을 분활의 중심축 사용 : 객체의 행동에 초점 (더 좋은 방법))
  - 상태 = 데이터

- 책임을 분활의 중심축으로 사용해야 더 좋은 설계
  - 객체의 상태는 **구현에 속하고** 불안정하기 때문에 변하기 쉽다
    - 구현에 관한 세부 사항이 객체의 인터페이스에 스며 들 수 있음 - 인터페이스에 의존하는 모든 객체에게 영향
  - 반대 객체의 책임은 **인터페이스**에 속함
    - 객체는 책임을 드러내는 안정적인 인터페이스 뒤로 책임 수행 로직에 필요한 상태 캡슐화

### 데이터를 준비하자
- 데이터 중심의 설계는 내부에 저장되는 데이터를 기반으로 시스템 분활
  - 객체 내부에 저장되는 데이터가 무엇인가?

## 설계 트레이드오프
- 객체지향 설계에서 좋은 설계를 판단 하기 위한 기준
  - 캡슐화, 응집도, 결합도

### 캡슐화
- 객체지향이 강력한 이유는 한 곳에서 일어난 변경이 전체 시스템에 줄 영향을 차단 가능
- 변경 가능성이 높은 부분은 내부로 숨기고 외부에는 상대적으로 안정적인 부분만 공개함
- **구현** : 변경 가능성이 높은 부분
- **인터페이스** : 상대적으로 안정적인 부분
- 캡슐화를 통해 유지보수성을 높힌다
  - 거침 없이 공개된 부분을 수정할 수 있어야함

### 응집도와 결합도
- 구조적 설계 방법이 주도하던 실절 품질 측정 - 하지만 객체 지향적 설계에서도 사용 가능
- **응집도** : 모듈에 포함된 내부 요소들의 연관도
  - 모든 요소들이 하나의 목적을 가지고 협력하면 굳
- **결합도** : 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지 측정
  - 다른 모듈에 대해 딱 필요한 지식만 알고 있어야함
- 좋은 설계는 *높은 응집도와 낮은 결합도*
  - 높은 응집도 : 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도
    - 만약 하나의 변경에 대해 다수의 모듈도 함께 변경돼야 한다면 응집도가 낮으거임
  - 낮은 결합도 : 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도
    - 인터페이스에 의존하도록 코드를 짜면 결합도가 낮아짐

## 03 데이터 중심의 영화 예매 시스템의 문제점
- 데이터 중심의 설계의 대표적인 문제점
  - 캡슐화 위반
  - 높은 결합도
  - 낮은 응집도

### 캡슐화 위반
- getFee/setFee를 통해 조회/설정을 할 수 있는데, 내부 클래스에 fee라는 인스턴스 변수가 존재한다는 것을 노골적으로 들어낸다
- design-by-guessing strategy: 너무 많은 접근자/수정자에 의존하는 설계

### 높은 결합도
- 하나의 객체들이 사용하는 로직/데이터가 하나의 객체에 집중됨
  - 많은 객체가 하나를 참조함으로 결합도가 올라감

### 낮은 응집도
- 낮은 응집도가 이르키는 두 가지 문제
  - 변경의 이유가 서로 다른 코드를 하나의 모듈에 뭉쳐놨기 때문에, 하나에서 변화 시 상관없는 코드가 영향을 받는다
  - 하나의 요구사항 변경을 위해 여러 묘듈 수정 필요


        단일 책임 원칙 (Single Responsibility Principle, SRP)
        - 클래스는 단 한 가지의 변경 이유만 가져야 한다

## 04 자율적인 객체를 향해
### 캡슐화를 지켜라
```java
class AnyClass {
  void anyMethod (Rectangle rectangle, int multiple) {
    rectangle.setRight(rectangle.getRight() * multiple);
    rectangle.setBottom(rectangle.getBottom() * multiple);
  }
}
```
- 문제점
  1. 코드 중복 발생 확률증가
     1. 위 와 같이 사각형 크기를 증가하려고 하면 getRight, setRight 반복적으로 불러야함
  2. 번경에 취약
     1. right, bottom을 length, width를 바꾸려하면 모든 코드를 변경해야 한다

```java
class Rectangle {
  public vid enlarge (int multiply) {
    right *= multiple;
    bottom *= multiple;
  }
}
```
- Rectangle을 변경하는 주체를 외부 객체에서 내부로
  - 크기 조정 증가의 "책임"을 이동

### 스스로 자신의 데이터를 책임지는 객체
- 상태와 행동을 객체라고 하나의 단위로 묶는 이유는 스스로 자신의 상태를 처리 할 수 있도록 하기 위함

## 05 하지만 여전히 부족하다
### 캡슐화 위반
- *isDiscountable(DayOfWeek dayOfWeek, LocalTime time)* 메서드의 시그니처를 통해 DiscountCondition의 속성이 노출
- 속성 변경이 있을 때 ripple effect가 더 커진다

        캡슐화의 전정한 의미
        - 그냥 내부 데이터를 외부로 노출하는 것이 아니라 변할 수 있는 어떤 것도 다 감춤
          - 내부 구현의 변화로 외부 영향이 생기면 캡슐화 위반

### 높은 캡슐화
```java
    public boolean isDiscountable (LocalDateTime whenScreened, int sequence) {
        for (DiscountCondition condition : discountConditionList) {
            if (condition.getType() == DiscountCondition.DiscountConditionType.PERIOD) {
                if (condition.isDiscountable(whenScreened.getDayOfWeek(), whenScreened.toLocalTime())) {
                    return true;
                }
            } else {
                if (condition.isDiscountable(sequence)) {
                    return true;
                }
            }
        }

        return false;
    }
```

- DiscountCondition의 내부 구현이 외부로 노출되어 Movie와 DiscountCondition 사이에 높은 결합도
- DiscountCondition에 어떤 변경이 있어도 Movie에 영향
  - 기간 할인 조건 명칭 PERIOD가 변경되었을 때 Movie에도 변경
  - DiscountCondition 종류 추가시 if ~ else 문 추가
  - DiscountCondition 만족 여부 판단하기 위한 정보 변경 시 isDiscountable 메서드로 전달하는 파람 변경

### 낮은 응집도
- 위와 같은 이유로 DiscountCondition에게 변화가 있을 때 Movie를 호출하는 Screening에도 영향
- **응집도가 낮은 이유는 캡슐화를 위반했기 때문이다**

## 06 데이터 중심 설계의 문제점
- 캡슐화를 위반하면 설계는 유연하지 못함
- 데이터 중심 설계가 변경에 취약한 점은
  - 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 관여함
  - 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션 결정

### 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다
- 데이터 중심 설계의 문제점
  - 테이터와 기능을 분리하는 절차적 프로그래밍으로 생기는 문제
    - **데이터는 구현의 일부**
  - 객체는 단순한 데이터의 집합체
  - 데이터를 먼저 결정하고 데이터를 처리하는 데 필요한 오퍼레이션을 나중에 결정하는 방식
    - 데이터에 관한 지식이 객체의 인터페이스에서 다 들어남

### 데이터 중심 설계는 객체를 고립시긴 채 오퍼레이션을 정의하도록 만든다
- 협력하는 객체들의 공동체를 고려하면서 설계해야함
- 설계의 무게 중심은 객체의 내부가 아니라 외부로 - 다른 객체와 어떻게 협력하는지
- 데이터 중심 설계는 *실행 문맥*에 대해 고민없이 구현
- 객체의 인터페이스 구현이 노출되면 안된다