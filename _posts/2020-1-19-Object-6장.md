---
layout: post
title: 03 역할, 책임, 협력6. 메시지와 인터페이스
---

- 객체지향 프로그래밍에 대한 가장 큰 오해 : 애플리케이션이 클래스의 집합
  - 클래스 : 개발자가 직접 만지고, 실험하고, 고쳐볼수 있는 실제적이고 구체적인 **도구**
- 객체가 구행하는 책임에 초점을 맞춰야한다 -> 애플리케이션은 클래스로 구성되어 있지만 **메시지**로 정의된다

## 01 협력과 메시지
### 클라이언트-서버 모델
- 메시지를 전송한 객체(클라이언트)의 요청에 대해 수신한 객체(서버)가 응답하는 구조
- 협력에 참여하는 객체들은 동시에 클라이언트와 서버의 역할을 수행하는 것이 일반적임
- 두 가지 메시지 집합
  1. 객체가 수신하는 메시지의 객체
  2. 외부의 객체에게 전송하는 메시지 집합

### 메시지와 메시지 전송
- 메시지 (message) : 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단
  
  - operation name과 argument로 구성되어 있음
- message sending/passsing : 한 객체가 다른 객체에게 도움을 요청하는 행위
- 오퍼레이션명 (operation name) :
- 인자 (argument) :

               수신자    오퍼레이션명    인자
        Java condition.isSatisfiedBy(screening)
        Ruby condition isSatisfiedBy screening

### 메시지와 메서드
- 메서드 (method) : 객체가 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저
- 동일한 이름의 변수 (condition)으로 동일한 메시지를 전송해도 다른 객체 타입에 따라 실행되는 메서드가 변경될 수 있음
  - 전통적으로는 개발자가 어떤 코드가 실행될지 정확하게 알고 있었음
  - 반변 메시지와 메서드라는 두 가지 다른 개념을 통해 컴파일러 시점, 실행 시점의 의미가 달라질 수 있음
- 메시지와 메서드 구분은 전송자/수신자 관계를 느슨하게 만듬 -> 전송자/수신자 사이를 "메시지"라는 가늘한 연결고리로 이어준다
  - 전송자는 어떤 메시를 전송해야 하는지만 알면 된다
  - 수신자가 어떤 클래스의 인스턴스인지, 어떤 방식으로 처리하는지 몰라도 된다

  
### 퍼블릭 인터페이스와 오퍼레이션
- 객체 안/밖은 뚜렷한 경계로 구분되어 있다
  - 외부에서 볼 때는 객체의 안쪽은 검은 장막으로 가려진 미지의 세계다
  - 오직 메시지를 통해 상호작용할 수 있다
  - public interface : 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합
- operation : 프로그래밍 언어 관점에서 퍼블릭 인터페이스에 포함된 메시지
  - 어떤 행동에 대한 *추상화*
  - 코드를 제외하고 단순히 메시지와 관련된 시그니처
- method : 메시지를 수신했을 때 실제로 실행되는 코드

        UML 용어로 말하면 : 오퍼레이션의 구현은 메서드다

- 퍼블릭 인페이스와 메시지의 관점으로 봤을 때 "메서드 호출" 보다 "오퍼레이션 호출"이 더 적절하다

### 시그니처
- operation(또는 method)의 이름 + 파라미터 목록
  - ? 오퍼레이션은 실행 코드 없이 시그니처만 정의함

## 02 인터페이스와 설계 품질
- 좋은 인터페이스 = **최소한 + 추상적인 인터페이스**
- 최소한 : 꼭 필요한 오퍼레이션만 인터페이스에 포함
- 추상적인 : 어떻게 수행하는지가 아니라 무엇을 하는지 표현
- 좋은 설계 방법 : 메시지를 먼저 선택함으로써 협력과 무관한 오퍼레이션이 스면드는 것을 방지
- 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법
  - 디미터 법칙 : 낯선 자에게 말하지 말라 (don't talk to strangers)
    - 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라
    - 다음의 인스턴스에만 메시지 전달
      - this의 객체, 속성, 속서인 컬렉션의 요소, 메서드 내에서 생성된 지역 객체, 메서드의 매개변수


            디미터 법칙과 갭슐화
            디미터 법칙은 캡슐화를 다른 관점에서 표현함. 협력과 구현이라는 사뭇 달라 보이는 두 가지 문맥을 하나의 유기적인 개념으로 통합함

  - 내부적 구조를 너무 잘 알다보면 **기차충돌(train wreck)** 코드 발생
      - example : screening.getMovie().getDiscountConditions();
    - 내부 정보를 묻지말고 단순히 수행하도록 요청하여라
  - 디미터 법칙은 객체가 자기 자신을 책임지는 자율적인 존재여야 한다는 사실을 강조

  - 묻지 말고 시켜라
    - 
  - 의도를 드러내는 인터페이스
  - 명령-쿼리 분리

## 03 원칙의 함정
- 설계는 트레이드오프의 산물
- 일관성을 잃어버리고 원칙을 맹목적으로 추종하면 안됨

### 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다

    IntStream.of(1,15,20,4,9).filter(x->x> 10).distinct().count();

- of, filter, distinct method는 IntStream의 동일한 클래스 인스턴스를 반환
- 디미터 법칙은 결합도와 관련된 것
  - IntStream 내부 구조가 외부로 노출되지 않았음 - 캡슐화 유지

### 결합도와 응집도의 충돌
- 묻지 말고 시켜라와 디미터 법칙을 준수한다고 항상 긍정적인 결과가 나오는 것은 아니다
- 위임 메서드 : 다른 클래스에게 질문하고 반환된 결과로 상태를 변경하는 상황
  - 질문, 판단, 상태변경을 모두 질문하는 틀래스에게 위임
- 맹목적으로 **위임 메서드**를 추가하면 *같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 된다*
  - 결과적으로 낮은 응집도
- 클래스는 하나의 변경 원인만 가져야한다
  - 서로 상관없는 책임들이 함께 뭉쳐있는 클래스는 응집도가 낮다
    - 작은 변화에 쉽게 무너짐

## 04 명령-쿼리 분리 원칙
- 묻지 말고 시켜라 규칙에 반대되는 상황 - 물어야할 때 명령-쿼리 (Command-query separation) 원칙을 알아두면 좋음
  - 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고
- routine : 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
  - procedure와 function으로 구분할 수 있음
    - procedure (명령): 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다
    - function (쿼리) : 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다
- 명령-쿼리 인터페이스 : 명령-쿼리 분리 원칙에 따라 작성된 객첵의 인터페이스

### 반복 일정의 명령과 쿼리 분리하기
- 하나의 메소드 안에 명령과 쿼리가 같이 존재하면 이해하기도 어렵고 버그를 생산하는 방법

### 명령-붜리 분리와 참조 투명성
- 참조 투명성 (referential transparency) :