# 09 유연한 설계

## 01 개방-폐쇄 원칙

- 개방-폐쇄 원칙 (Open-Closed Principle, OCP) :  소프트웨어 개체 (클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다
  - 확장에 대해 열려 있다 - 요구사항 변경 시 새로운 동작이 **추가**됨으로 기능 확장
  - 수정에 대해 닫혀 있다 : 기존 '코드'를 수정하지 않고 동작 추가/변경 가능

### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라

- 개방-폐쇄 원칙은 런타임/컴파일타임 의존성 이야기
  - 각 시각에 대한 의존성은 다른 의미를 가지게 된다
- 새로운 클래스를 추가함으로써 새로운 컨텍스트가 사용되도록 확장 가능
- 개방-폐쇄 원칙을 수용하는 코드 : 컴파일타임 의존성을 수정하지 않고 런타임 의존성을 쉽게 변경 가능

### 추상화가 핵심이다

- 핵심은 **추사화에 의존하는 것**
  - 추상화 : 핵심적인 부분만 남기고 불필요한 부분을 생략함으로써 복잡성을 극복함
    - 문맥이 바뀌더라도 변하지 않는 부분만 남게 되고 문맥에 따라 변하는 부분이 생략된다 -> 생략된 부분은 문맥에 따라 채워넣워 적합한 기능을 구체화하고 확장 가능
  - 어떤 개념을 추상화했다고 수정에 대해 닫혀 있는 설계를 만들 수 있는 것이 아니다
    - 의존성의 방향이 중요함
    - 변경에 의한 파급효과를 피하기 위해서는 *무엇이 변하지 않고* 무엇이 *변하는 지* 구분해야함

## 02 생성 사용 분리

- 결합도가 높아질수록 개방-폐쇄 원칙을 따르는 구조를 설계하기 어려움

  - 알아야 하는 지식이 많으면 결합도가 높아짐 - 객체 생성이 과도한 지식을 요구함

- 하지만 객체 생성을 피할 수는 없다 -> 문제는 부적절한 곳에서 객체가 생성됨

  - e.g Movie에서 DiscountPolicy를 생성하고 나중에 메서드 호출 시 이 객체를 메시지로 전달한다

- 동일한 클래스에 객체 생성과 사용이 공존하면 이질적임

  - **생성과 사용 분리 (separation use from creation)**을 해야함

    - 보편적으로 생성할 책임을 클라이언트로 옮김 - 현재 컨텍스트에 대한 결정권을 가지고 있는 클라이언트로 컨텍스트 지식을 옮기면 해당 객체가 하나의 클라이언트에게 결합되지 않음

      

### Factory 추가하기

- 생성을 클라이언트로 옮긴 배경은 Movie는 특정 컨텍스트에 묶이면 안되고 클라이언트는 오케이

- 하지만 보면 클라이언트도 생성/사용 책임을 가짐 - 다른 방법이 필요함

- FACTORY 객체 - 생성과 사용 분리를 위한 특화 객체

  - 클라이언트는 FACTORY를 *사용*해서 생성된 객체를 *사용*

    

### 순수한 가공물에게 책임 할당하기

- GRASP : 정보를 가장 많이 알고 있는 INFORMATION EXPERT에게 책임 할당
  - 도메인 모델은 정보 전문가를 찾기 위해 참조할 수 있는 일차적 재료 -> factory는 도메인 모델에 속하지 않음
  - 전체적으로 결합도 낮추고 재사용성 증가 시키기 위해 도메인 개념과 상관없는 가공의 객체임
- 시스템을 객체로 분해하는 두 가지 방식
  - 표현적 분해 (representational decomposition) : 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해
    - 도메인 모델에 담겨 있는 개념과 관계를 따름
    - 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것이 목적
    - 객체지향 설계의 가장 기본 접근법
  - 행위적 분해 (behavioral decomposition) : 
  - 모든 책임을 도메인 객체에게 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하
    - **PURE FABRICATION**(순수한 가공물) :  도메인과 무관한 인공적인 객체
      - 행위적 분해로 인해 생성되는 것이 일반적
- 객체지향은 도메인 개념뿐만 아니라 임의적으로 창조된 인공적 추상화도 포함
  - 품질의 측면에서 균형을 맞추는 데 필요한 객체들
  - 처음은 도메인 객체로 시작하고 도메인 개념이 만족스럽지 않다면 인공 객체로



## 03 의존성 주입

- 의존성 주입 : 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법
- 의존성 주입에서 의존성 해결 방법
  - 생성자 주입 (constuctor injection) : 객체 생성하는 시점
  - setter 주입 (setter injection) : 객체 생성 후 setter method 사용
    - 단점 : 어떤 의존성이 필수적인지 명시적으로 표현 못함
    - 단점 : 객체 생성되고 setter 호출전까지 불완전함
  - 메서드 주입 (method injection) : 메서드 실행 시 인자 이용
    - 의존성이 필요한 유일한 경우 사용
  - 인터페이스 주입 (interface injection) : 주입할 의존성을 명시하기 위함



### 숨겨진 의존성은 나쁘다

- service locator : 의존성을 해결할 객체들을 보관하는 일종의 저장소
  - 외부에서 객체에게 의존성을 전달하는 의존성 주입과 다름
  - 객체가 직접 service locator에게 의존성을 해결해줄 것을 **요청**
  - 단점 : 의존성을 감춤
    - 의존성 문제를 컴파일타임이 아니라 런타임에 발견할 수 있음
  - 단점 : 단위 테스트 작성도 어렵다
    - 일반 단위 테스트 프레임워크는 테스트 케이스 단위로 테스트에 사용될 객체들을 새로 생성함
    - ServiceLocator은 내부적으로 정적 변수로 객체를 관리함 -> 각 단위 테스트는 서로 고립돼야 한다는 기본 원칙 위반
    - 문제 원인 : 숨겨진 의존성은 캡슐화 위반
      - private을 선언하고 변경되는 내용을 숨긴다고 캡슐화를 지키는게 아니다
      - 캡슐화는 코드를 읽고 이해하는 행위와 관련 있음 -> 퍼블릭 인터페이스만 보고 이해해야되지만 사용법을 위해 구현 내부를 뒤져야 하면 캡슐화가 무너진거임
- 숨겨진 의존성의 가장 큰 문제점 : 의존성을 이해하기 위해 코드 내부 구현이해를 강요함
  - 의존성의 대상을 설정하는 시점 <-> 의존성 해결 시점 (멀어짐) : 이해 + 디버깅이 어려워진다
- 의존성 주입의 장점
  - 퍼블릭 인터페이스에 명시적으로 의존성을 드러냄
  - 의존성 문제는 컴파일타임에 잡을 수 있음
    - 필요한 인자 추가하지 않을 경우 에러
  - 단위 테스트 시 객체를 추가하거나 제거할 필요없음



## 04 의존성 역전 원칙

### 추상화와 의존성 역전

```java
public class Movie {
    private AmountDiscountPolicy discountPolicy;
}
```

-  취약점 : 요금을 계산하는 **상위**정책이 요금 계산하는 데 필요한 구체적인 방법요구
  - 상위 수준 클래스 Movie가 하위 수준 클래스 AmountDiscountPolicy에 의존함
- 객체 사이의 협력의 본질은 상위 수준 정책이 담고 있음
  - ex. Movie 와 AmountDiscountPolicy사이의 본질은 영화 가격 계산, not 어떻게 계산
- 상위가 하위에 의존하면 하위 변경 시 상위도 영향을 받음
  - **의존성 방향이 잘못됨**: 어떤 식으로든 하위 수준의 클래스에 의존하면 안된다
- 대부분 재사용의 대상은 상위 수준 클래스 -> 상위 재사용 시 하위 수준 클래스도 필요하기 때문에 재사용이 어려워짐
  - 추상화로 해결  

> 의존성 역전 원칙 (Dependency Inversion Principle)
>
> ​	- 역전(inversion) : 의존성 역전 원칙을 따르는 설계는 의존성의 방향이 전통적인 절차형 프로그래밍과는 반대 방향으로 나타나기 때문
>
> 1. 상위 수준 모듈은 하위 수준의 모듈에 의존하면 안 된다. 둘 모두 추상화에 의존해야함
> 2. 추상화는 구체적인 사항에 의존해서는 안 된다.

### 의존성 역전 원칙과 패키지

- 역전은 의존성의 방향뿐만 아니라 인터페이스 소유권에도 적용됨
- 객체지향 프로그래밍 언어에서는 어떤 구성 요소의 소유권을 결정하는 것은 모듈임
  - 자바는 패키지 이용해서 모듈 구현
- 코드 컴파일을 할 때 꼭 필요한 코드 - 같은 패키지
  - 불필요한 코드는 쓸 때 없이 재컴파일/재배포 된다
  - 추상화를 클라이언트와 같은 패키지에 넣어야 한다 -> 클라를 특정한 컨텍스트로 부터 완벽하게 독립시킴

## 05 유연성에 대한 조언

### 유연한 설계는 유연성이 필요할 때만 옳다

- 유연하고 재사용 가능한 설계 : 동일한 컴파일타임 의존성으로 부터 다양한 런타임 의존성을 만들 수 있는 코드
- 가끔 유연 < 단순하고, 명확한 설계
- 유연 = 복잡, 클래스 구조 <-> 객체 구조 거리가 멀어짐
- 단순하고 명확한 해법 vs 유연성

### 협력과 책임이 중요하다

- 협력에 참여하는 객체가 다른 객체에게 어떤 메시지를 전송하는지가 중요
  - 결국 역할, 책임, 협력하는 모습이 중요