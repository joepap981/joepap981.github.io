---
layout: post
title: 7. 객체 분해
---

- 추상화 : 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업
  - 분해 (decomposition) : 큰 문제를 해결 가능한 작은 문제로 나누는 작업
## 01 프로시저 추상화와 데이터 추상화
- 프로시저 추상화 : 소프트웨어가 무엇을 해야하는지
  - 기능 분해 (functional decomposition/algorithmic decomposition)
- 데이터 추상화 : 소프트웨어가 무엇을 알아야 하는지 추상화
  - 데이터 중심적인 type abstraction (abstract data type):
  - 데이턴 중심적인 procedure  (object oriented):

## 02 프로시저 추상화와 기능 분해
### 메인 함수로서의 시스템
- 기능 분해 관점에서는 시스템으 프로시저 단위로 분해된다
  - 반복적으로 실행되거나 거의 유사하게 실행되는 작업들은 하나의 장소에 모아놓음
    - 로직 재사용 + 중복 방지
  - 상세한 구현 내용을 모르더라도 인터페이스만 알면 프로시저 사용 가능
- 기능 분해의 전통적인 방법 : 하향식 접근법 (top-down approach)
  - 최상위 기능 정의 후 기능을 조금 더 작은 기능으로 분해

### 급여 관리 시스템
    최상위 : 직원의 급여를 계산한다
      사용자로부터 소득세율을 입력받는다
      직원의 급여를 계산한다
      양식에 맞게 결과를 출력한다

- 기능 분해 결과 : 최상위 기능을 수행하는 데 필요한 절자들을 실행하는 시간 순서
- 기능 중심적으로 필요한 데이터를 결정한다
  - 기능을 분해하고 정제하는 과정에 필요한 데이터 종류/저장 방식 식별

### 급여 관리 시스템 구현
```Ruby
def main(name)
  taxRate = getTaxRate()
  pay = calculatePayFor(name, taxRate)
  puts(describeResult(name, pay))
end
```
- 시스템 최상위의 가장 추상적인 main 함수를 정의하고, 메인 함수를 구현 가능한 수준까지 **세부적인 단계로** 분해하는 방법

### 하향식 기능 분해의 문제점
- 시스템은 하나의 메인 함수로 구성돼 있지 않다
- 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다
- 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다
- 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시킴 : 유연성 + 재사용 저하
- 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다

#### 하나의 메인 함수라는 비현실적인 아이디어
- 어느 시스템도 처음 릴리스됐던 모습을 유지하지 않는다
  - 새로운 기능 추가 -> 메인 함수는 동등하게 중요한 여러 함수들 중 하나로 전락함
- 하향식 접근법은 하나의 알고리즘 구현하거나 배치 처리 구현 가능 : 현대 상호작용 시스템 개발에는 부적합함
- **셀제 시스템에 정상(top)이란 존재하지 않는다 [Meyer00]**

#### 메인 함수의 빈번한 재설계
- 시스템 안에 "유일한" 정상으로 간주하는 하향식 기능 분해 = 빈번한 메인 함수 수정
- 기존 코드 수정은 새로운 버그를 만들 확율을 높임
- 시스테은 여러 개의 정상으로 구성되기 때문에, 새로운 정상을 추가할 때 마다 기존 "정상"의 내부 구현을 수정할 수 밖에 없음

#### 비즈니스 로직과 사용자 인터페이스의 결합
- 하향식 접근법은 비즈니스 로직 설계 초기 단계 부터 *입력/출력* 방식을 함께 고민하도록 강요함
  - 코드 안에서 비즈니스 로직과 사용자 인터페이스 로직이 밀접하게 결합됨
- 문제 : 사용자 인터페이스가 비즈니스 로직보다 변경이 더 빈번함
- "관심사의 분리" 라는 아키텍처 설계의 목적을 달성하기 어려움

#### 성급하게 결정된 실행 순서
- 설계 초기 단계 부터 시스템이 *무엇(what)*을 해야 하는지 보다 *어떻게(how)* 동작해야 하는지에 집중하게 만듬
- 처음부터 구현을 염두하기 때문에 *시간 제약(temporal constraint)*을 강조한다
- 실행 순서, 조건, 반복같은 제어 구조를 미리 정해서 *중앙집중 제어 스타일 (centralized control style)*
  - 모든 중요한 제어 흐름은 상위 함수에서 이뤄진다
  - 하위 함수는 상위 함수의 흐름에 따라 호출됨
- 문제1 : 기능 추가 될 때 마다 초기 결정된 함수들의 제어 구조와 다름
- 해결 방법 : 시간적인 제약말고 *논리적 제약 (logical constraint)*
  - 객체 사이의 논리적인 관계 중심 설계
  - 하나의 구성요소로 제아가 집중되지 않고 제어 주체가 분산됨
- 문제2: 함수 재사용도 어려움
  - 상위 함수가 강요하는 문맥(context) 안에서만 의미를 가진다
  - 다른 함수들과 시간적으로 강하게 결함됨 -> 사소한 변경이 거대한 여파

#### 데이터 변경으로 인한 파급효과
- 어떤 데이터를 어떤 함수가 사용하고 있는지 추적 어려움
  - 데이터 변경이 이르클 파급효과 예상 어려움
- 데이터 변경으로 인한 영향 최소화를 위해 데이터와 함께 변경되는 부분 + 안되는 부분을 명확히 구분해야함
  - 데이터 변겨오디는 부분을 하나의 구현 단위로 묶고 외부에서 제공되는 함수로만 데이터에 접근해야함 : 잘 저의된 퍼블릭 인터페이스 통해 데이터 접근
- 의존성 관리 핵심 : 변경에 대한 영향 최소화
  - 영향 받는 부분 vs 안 받는 부분 구분

### 언제 하향식 분해가 유용한가
- 어느 정도 안정화 된 후 설계의 다양한 측면을 논리적으로 설명할 때
- 하향식 설계 문제 점
  1. 하나의 함수에 제어가 집중되기 때문에 확장 어려움
  2. 초기 설계에 본질적인 측면을 무시하고 사용자 인터페이스 같은 비본질적인 것에 집중함
  3. 과도하게 함수에 집중하게 함으로써 소프트웨어의 중요한 다른 측면인 **데이터**에 대한 영향도를 파악학기 어렵게 만듬

## 03. 모듈
### 정보 은닉과 모듈
- 기본 전략 : 변경되는 부분을 하나의 구현 단위로 묶고 퍼블릭 인터페이스를 통해 접근
- 정보 은닉 : 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 함
- 기능 분해 : 하나의 기능을 구현하기 위해 필요한 기능들을 순차적으로 찾아가는 과정
- 모듈 분해 : 감춰야 하는 비밀을 선택하고 비밀 주변에 안정적인 보호막 치기
- 모듈이 감춰야 하는 두 가지 비밀
  1. 복잡성 : 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 복잡도를 줄임
  2. 변경 가능성 : 변경 가능한 설계 결정이 외부로 노출될 경우 파급효과가 커짐

### 모듈의 장점과 한계
#### 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다
- 내부에 정의된 변수를 직접 참조하는 코드를 모듈 내부로 제한함
  - 데이터가 변경되도 영향 받는 함수는 데이터를 정의한 모듈에만 있음

#### 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다
- 화면 출력을 모듈 밖으로 보내고 비즈니스 로직은 모듈 내로 변해 GUI 같은 형식의 인터페이스를 추가해도 모듈에 포함됨 비즈니스 로직에는 영향이 가지 않음

#### 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다
- 네임스페이스를 제공함으로 다른 모듈에서도 동일한 이름 사용가능
- name collision 방지
###
- 모듈에 있어 핵심은 데이터다
- 모듈에서 감춰야 할 데이터를 정의하고 데이터를 조작하는 데 필요한 함수를 결정
- 기능이 아니라 데이터 중심으로 시스템을 분해한다
- 모듈의 가장 큰 단점 : 인스턴스의 개념을 제공하지 않음
  - ex. Employees 모듈은 회사에 속한 *모든 직원* 정보를 가지고 있다
    - 높은 수준의 추상화를 위해서는 전체가 아닌 개별 단위로 제어 가능해야함 -> 추상 데이터 타입

## 04. 데이터 추상화와 추상 데이터 타입 
### 추상 데이터 타입
- **타입(type)**: 변수에 저장할 수 있는 내용물의 종류 + 적용될 수 있는 연산
  - 연산의 집합을 정의하기 때문에 변수의 값의 행동을 예측 가능하게 함
- Abstract Data Type의 필요 : 데이터 추상화, 정보 은닉, 데이터 캡슐화, 인터페이스-구현 분리가 녹여들어 있음
- 추상 데이터 타입 구현을 위해 필요한 프로그래밍 언어 지원
  - 타입 정의 선언
  - 오퍼레이션의 집합 정의
  - 제공된 오퍼레이션으로만 조작 가능하게 외부로 부터 보호
  - 탑에 대해 여러 개의 인스턴스 생성 가능
- 상태와 행위를 가지는 독립적인 객체라 사람들의 사고방식에 가까움
  - 전체 직원을 캡슐화하는 모듈보다
- 추상 데이터 타입의 의도 : 프로그래밍 언어가 제공하는 타입처럼 동작하는 내장 데이터 타입가 동일

## 05. 클래스
### 클래스는 추상 데이터 타입인가?
- 추상 데이터 타입 =/ 클래스
  - 객체지향 프로그래밍 vs 객체기반 프로그래밍
  - 핵심적인 차이점 : 클래스는 상속+다형성 제공
  - 타입을 추상화 vs 절차를 추상화
- 추상 데이터 : ex. Employee라는 타입 안에 암묵적으로 두 가지 타입이 있음
- 클래스 : 명시적으로 두 가지 타입을 구분하고 이에 맞는 오퍼레이션을 구현함

### 변경의 기준으로 선택하라
- 클래스가 추상 데이터 타입의 개념을 따르는지 확인하는 방법
  - 인스턴스 타입을 명시적으로 표현하는 변수 확인 : 객체지향을 위반하는 행위
- 객체지향에서는 타입 변수를 이용한 조건문을 **다형성으로** 대체함
  - 객체의 타입을 확인한 후 메서드 호출 x
  - 메시지를 처리할 적절한 메서드를 선택 (클라이언트 코드 수정 불필요)
  - **개방-폐쇄 원칙(Open-closed Principle, OCP)** : 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형 + 행위 추가 가능
- 언제 추상 데이터 타입 vs 객체지향
  - 타입 추가 -> 객체지향
    - 새로운 타입이 추가되면 클라이언트를 일일이 찾아 확인
  - 오퍼레이션 추가 -> 추상 데이터 타입
    - 객체지향인 경우 오퍼레이션 추가 시 상속 계층에 속하는 모든 클래스 수정

### 협력이 중요하다
- 중요한 것은 역할, 책임, 협력
  - 협력이라는 문맥 고려하지 않고 오퍼레이션 구현 방식을 타입별로 분배 = x
  - 협력에 필요한 책임을 수행하기 위해 어떤 객체가 필요한지 고미 후 타입 계층 안에 각 절차 추상화
    - 타입 계층 + 다형성은 **협력**이라는 문맥 안에서 **책임**을 수행하는 한 가지 방법