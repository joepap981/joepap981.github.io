---
layout: post
title: 8. 의존성 관리하기
---

- 잘 설계된 객체지향 애플리케이션은 : 작고, 응직도 높은 객체들로 구성
  - 작고 응집도 높은 객체 
    1. 초점이 명확
    2. 한 가지 일만 잘 하는 객체
- 다른 객체와 협력을 할 수 밖에 없다 - 따라 의존성이 발생 할 수 밖에 없다
  - 과도한 의존성은 애플리케이션 수정을 어렵게 만듬
  
  - 설계의 핵심 : 협력에 필요한 의존성을 유지 하면서 변경을 방해하는 의존성 제거
  
    

## 01 의존성 이해하기

### 변경과 의존성

- 의존성은 **실행 시점** 과 **구현 시점**에 서로 다른 의미를 가짐
  - 실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서 실행 시에 의존 대상 객체가 반드시 존재해야함
  - 구현 시점 : 의존 대상 객체가 변경될 경우 의존하는 객체도 함게 변경됨

```java
public class PeriodCondition implements DiscountCondtion {
    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;
}
```

- 샘플에서 보이는 것과 같이 다양한 의존성의 종류
  - UML에서는 두 요소 사이에 존재할 수 있는 다양한 관계의 하나로 의존 관계로 정의 - 모든 관계는 의존성이라는 개념을 포함한다
    - 실체화 관계 (realization)
    - 연관 관계 (association)
    - 의존 관계 (dependency)
    - 일반화/특수화 관계 (generalization/specialization)
    - 합성 관계 (composition)
    - 집합 관계 (aggregation)
    
  - ex. 실체화 관계(realization), 연관 관계(association), 의존 관계(dependency)
  
    

### 의존성 전이

- 의존성은 저이될 수 있다
- 의존성 전이 (transitive dependency) : A가 B에 의존하면 A는 B가 의존하는 대상에 대해서도 자동으로 의존함
- 의존성은 함께 변화될 수 있는 *가능성* 을 이야기하는 것 - 무조건 전이 되는건 아님
  
  - 직접 의존성 (direct dependency)  vs 간접 의존성 (indirect dependency) 
  
    

### 런타임 의존성과 컴파일타임 의존성

- run-time dependency : 애플리케이션이 실행되는 시점
- compile-time dependency : 코드 자체 /작성된 코드를 컴파일하는 시점
  - 시간이 아니라 작성한 코드의 구조를 중요시 함
  - 문맥에 따라 컴파일 진행 시점 vs 코드를 작성한 시점 구분 필수

- 럼타임, 컴파일타임 의존성이 다를 수 있다
  - 유연하고 재사용 가능한 코드를 위해서는 두 종류의 의존성을 서로 **다르게** 만들어야 한다
  - ex . AmountDiscountPolicy와 PercentDiscountPolicy는 컴파일타임에는 전혀 관계가 없지만 런타임에는 Movie가 두 인스턴스와 협력해야한다.
    - Movie가 두 클래스의 인스턴스에 대해 모르게 하고 추상 클래스에 의존하게 만든다

<img src="08.의존성_관리하기.assets\image-20200101224853099.png" alt="image-20200101224853099" style="zoom:60%;" />

<img src="08.의존성_관리하기.assets\image-20200101225035542.png" alt="image-20200101225035542" style="zoom:63%;" />

- 유연하고 재사용 가능한 설계를 창조하기 위해서는 **동일한** 소스코드 구조를 가지고 **다양한** 실행 구조를 만들 수 있어야한다

- 클래스가 협력할 객체가 어떤 것인지는 런타임에 해결해야 한다.

  

### 컨텍스트 독립성

- 클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안됨
  - 어떤 문맥에서 사용될 것인지를 구체적으로 명시하는 것과 같음
  - 특정 문맥에 결합될수록 다른 문맥에서 사용하기 힘들어짐
  
- 컨텍스트 독립성 : 클래스가 사용될 때 특정한 문맥에 대해 최소한의 가정만 이뤄져 다른 문맥에서도 재사용하기가 수월함

  

### 의존성 해결하기

- 의존성 해결 : 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 3 가지 방법
  - 객체를 생성하는 시점에 생성자를 통해 의존성 해결
  - 객체 생성 후 setter 메서드를 통해 의존성 해결
    - 장점 : 실행 시점에 의존 대상을 변경할 수 있기 때문에 좀 더 유연함
    - 단점 : 객체를 생성하고 대상이 설정하기 전까지 객체의 상태가 불완전할 수 있다
  - 메서드 실행 시 인자를 이용해 의존성 해결

- 생성자 방식 + setter 방식 혼합
  
  - 완전한 객체를 생성 후 setter로 변경 가능하게 만듬
  
    

## 02 유연한 설계

- 의존성 관리를 위한 유용한 몇 가지 원칙

  

### 의존성과 결합도

- 객체치향 패러다임의 근간은 협력이다
  - 협력하기 위해서는 서로의 존재와 수행 가능한 책임을 알아야함 - 의존성 발생
  - 따라 모든 의존성은 나쁘지 않지만 과하면 문제가 됨
- 바람직한 의존성은 **재사용**과 관련있다
  - 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못함
  - **느슨한 결합도 (loose coupling)** 이 바람직한 의존성

> 의존성과 결합도
>
> 동의어로 사용하지만 다른 관점에서 관계의 특성을 이야기 함. 의존성을 이야기할 때는 의존성의 **유무**를 이야기하고 결합도는 **정도**



### 지식이 결합을 낳는다

- 결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정 됨

  - 알 수록 더 적은 컨텍스트에서 재사용 가능하다 - 협력하는 대상에 대해 필요한 정보 외는 최대한 감춰야 함

    

### 추상화에 의존하라

- 추상화 : 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 **복잡도를 극복하는 방법**

  - 알아야 하는 대상에 대한 지식의 양을 줄이기 때문에 결합도를 느슨하게 유지함

- 의존 대상의 결합도 정도

  - 구체 클래스 의존성 (concrete class dependency)

  - 추상 클래스 의존성 (abstract class dependency)

    - 구체 클래스 보다는 클라이언트가 알아야 하는 지식의 양이 적다
    - 하지만 상속 계층이 무엇인지에 대해 알아야함

  - 인터페이스 의존성  (interface dependency)

    - 협력하는 객체가 어떤 메시지를 수신할 수 있는지에 대한 지식만 남음

      

### 명시적 의존성

- 결합도를 느슨하게 만들기 위해 인스턴스 변수의 타입을 추상 클래스나 인터페이스로 선언하는 것만으로 부족함

- 명시적인 의존성 (explicit dependency) : 퍼블릭 인터페이스로 의존성을 노출함

  - ex. Movie에 생성자에 DiscountPolicy를 노출 시키는 점

- 숨겨진 의존성 (hidden dependency) : 퍼블릭 인테페이스로 의존성이 노출되지 않음

  - ex. Movie 내부에서 AmountDiscountPolicy 인스턴스를 직접 생성
  - 단점 : 의존성 파악을 위해 내부 구현을 봐야함 -> 변경을 위해 내부 구현을 직접 바꿔야함

- **의존성은 명시적으로 표현되어야 함**

  

### new는 해롭다

- new를 잘못 사용하면 클래스 사이의 결합도가 극단적으로 높아진다

- new가 해로운 두 가지

  - 구체 클래스의 이름을 직접 기술해야 한다 -> 추상화가 아닌 구체 클래스에 의존할 수 밖에 없음 (결합도 높아짐)
  - 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지 알아야 함 -> 지식의 양이 늘어남 (결합도 높아짐)

- 해결 방법 : **인스턴스 생성 로직**과 **생성된 인스턴스 사용**하는 로직 분리

- 유연한 설계

  - 사용과 생성의 책임 분리

  - 명시적으로 의존성을 드러내고

  - 구체 클래스가 아닌 추상 클래스 사용

    

### 가끔은 생성해도 무방하다

- 클래스 안에서 객체의 인스턴스 직접 생성하는 경우 -> 기본 객체 설정

- 해결 방법

  - 생성자 체이닝 : 추가된 생성자에서 인스턴스 생성
  - 메서드 오버라이딩 : 인스턴스를 받는 메서드 + 안 받는 메서드 선언

- 설계는 트레이드오프 활동

  - 결합도 vs 사용성

    - 구체 클래스에 의존하더라도 클래스의 사용성이 더 중요하다면 결합도를 높이는 방향도 ok

      

### 표준 클래스에 대한 의존은 해롭지 않다

- 의존성이 불편한 이유 : 변경에 대한 영향을 암시함
  - 따라 변경될 확률이 거의 없는 클래스라면 의존성은 문제가 되지 않음
    - ex. JDK 표준 컬렉션 라이브러리
