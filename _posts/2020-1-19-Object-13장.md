---
layout: post
title: 13 서브클래싱과 서브타이핑
---

- 상속의 두 가지 용도
  - 타입 계층 구현
    - 부모 클래스가 일반적인 개념 구현 (generalization), 자녀가 특수한(specialization) 개념 구현
  - 코드 재사용
    - 쉽고 간단하게 확장 가능하지만 부모/자식 간의 높은 결합도 때문에 변경에 취약함
  - 결론 : 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체 구현이 필요 (타입 계층 구현)
- 타입 계층이 무엇인가?

> 객체지향 vs 객체기반
>
> 객체지향은 **상속과 다형성** 지원

## 01 타입

### 개념 관점의 타입

>  타입 : 인지하고 있는 세상의 사물의 종류

- 타입 : 인식하는 객체들에 적용하는 개념/아이디어
  - ex. ''프로그래밍 언어'' 라는 **타입의** **인스턴스(객체)들**: 자바, 루비, 자바스크립트, C 

- 타입의 3가지 요소
  - 심볼 (symbol) - 타입의 이름
  - 내연 (intension) - 타입에 속하는 객체들의 공통 속성/행동
  - 외연 (extenson) - 타입에 속하는 객체들의 집합

### 프로그래밍 언어 관점의 타입

> 타입 : 연속적인 비트에 의미와 제약을 부여하기 위한 개념

- 프로그래밍 언어의 타입의 사용 목적
  - 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의함
    - ex. 숫자 타입에 '+' 연산자 사용 가능
  - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공함
    - '+' 숫자는 문자열에 따라 다른 행동이 정해짐
- 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써
  1.  코드의 의미를 명확하게 전달
  2. 개발자 실수 방지

### 객체지향 패러다임 관점의 타입

- 객체지향 프로그래밍에서의 오퍼레이션 : 객체가 수신할 수 있는 메시지
  - 수신할 수 있는 메시지 집합 : 퍼블릭 인터페이스

> 객체의 퍼블릭 인터페이스가 객체의 타입을 결정함 - 동일한 퍼블릭 인터페이스를 제공하는 객체들을 동일한 타입으로 분류

- 객체가 외부에 제공하는 행동에 초점을 맞춰야함
- 객체의 타입을 결정하는 것은 *내부 속성이 아니라* **외부에 제공하는 행동**

## 02 타입 계층

### 타입 사이의 포함관계

- 수학에서 집합은 다른 집합 포함 가능
  - 타입 역시 객체들의 집합 - 다른 타입 포함 가능
- 동일한 인스턴스가 하나 이상의 타입으로 분류되는 것도 가능
- 포함하는 타입은 외연 관점에서 더 크고 내연 관점에서는 더 일반적임
  - 더 일반적인 타입 : 슈퍼타입 (supertype) - superset
    - 집합이 다른 집합의 모든 멤버를 포함한다
    - 타입 정의가 다른 타입보다 좀 더 일반적임
  - 더 특수한 타입 : 서브타입 (subtype) - subset
    - 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다
    - 타입 정의가 다른 타입보다 좀 더 구체적이다

### 객체지향 프로그래밍과 타입 계층

- 객체 타입을 결정하는 것은 퍼플릭 인터페이스
- 슈퍼타입 : 서브타입이  정의한 퍼블릭 인터이스를 일반화
  - 상대적으로 더 범요적이고 넓은 의미로 정의
- 서브타입 : 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화
  - 상대적으로 구체적이고 좁은 의미로 정의
- 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주

## 03 서브클래싱과 서브타이핑

- 상속을 이용해 타입 계층 구현 == 부모 클래스가 슈퍼타입 역할, 자식이 서브타입 역할을 할 수 있게 **관계 정의**

### 언제 상속을 사용해야 하는가?

- 상속 사용 용도 == 타입 계층 구현
- 이럴 때 사용한다 -
  1. 상속 관계가 is-a 관계를 모델링하는가?
     - 우선 어휘적으로 만족 + 행동도 만족
  2. 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
     - 행동 호환성 : 클라이언트가 부모/자식 클래스 차이점을 몰라야함

### is-a 관계

- 어휘적으로 is-a 관계를 만족
  - ex. S가 T의 일종이면 "타입 S는 타입 T다 (S is-a T)" 라고 말할 수 있어야함
- 행동에 따라 타입 계층을 구성해야함
  - ex. 어휘적으로 새는 난다 -> 팽귄은 새다 -> 팽귄은 난다
    - 팽귄은 날지 못함으로 새의 서브타입이 될 수 없다
- 타입 계층의 의미는 결국 **문맥에 따라 달라질 수 있다**
  - 슈퍼/서브 타입의 관계에서 is-a 보다 행동 호환성이 더 중요함

### 행동 호환성

- 행동에 연관성이 없으면 is-a 관계를 사용하지 말아야함
- 행동 호환 여부는 **클라이언트 관점**
  - 클라이언트가 두 타입이 동일하게 행동할 것이라고 판단하면 두 타입을 타입 계층으로 묶음 가능
    - ex. 팽귄이 새가 아닌 이유는 클라이언트가 모든 새가 날 수 있다고 가정
      - 해결 방법 - fly를 비워 두거나 예외를 던지게 하면됨
        - 문제 : 다른 날지 못하는 새가 추가되면 새로운 타입을 확인하는(instanceof) 코드 추가 - 개방-폐쇄 원칙 위반

### 클라이언트의 기대에 따라 계층 분리하기

- 클라이언트의 기대에 맞게 상속 계층 분리를 해야한다

  - ex. 클라이언트가 날수 있는 새와 없는 새를 구분하여 협력한다는 것을 명시적으로 구분

    - Bird = 날 수 없는 새와만 협력, FlyingBird = 날 수 있는 새와 협력

    ![image-20200111123020375](13.서브클래싱과_서브타이핑.assets\image-20200111123020375.png)

  - ex. 인터페이스로 걷는 새, 나는 새 구분

    ![image-20200111122934332](13.서브클래싱과_서브타이핑.assets\image-20200111122934332.png)

  - 팽귄이 코드 재사용을 위해 Bird를 상속 받지 못함 - fly 오퍼레이션 추가

    - 코드 재사용을 위한 상속 금지 -> 합성
    - ex. 합성을 사용한 Bird 인터페이스 재사용

    ![image-20200111123421608](13.서브클래싱과_서브타이핑.assets\image-20200111123421608.png)

- 이터페이스 분리 원칙 (Interface Segregation Principle, ISP):클라이언트에 따라 인터페이스를 분리하면 변경에 대한 영향을 더 세밀하게 제어할 수 있게 된다
  
  - 요구가 바뀌더라도 영향의 파급 효과를 효과적으로 제어 가능
- 설계가 항상 현실 세계를 반영할 필요없음 
  
  - 도메인의 요구사항이 더 중요함 - 불필요하게 설계를 복잡하게 만들 필요없다
- 요점 : 자연어에 현혹되지 말고 *요구사항 속에서* **클라이언트의 기대**에 집중

### 서브클래싱과 서브타이핑

- 어떤 상속이 올바른 상속인가?
  - 상속의 종류 : 서브클래싱 + 서브타이핑
- 서브클래싱 (subclassing) : 다른 클래스의 **코드를 재사용**할 목적으로 상속을 사용하는 경우
  - 자식 클래스와 부모 클래스의 행동이 호환되지 않음 - 대체 불가
  - 구현 상속 (implementation inheritance) / 클래스 상속 (class inheritance) 라고도 부름
- 서브타이핑 (sub typing) : **타입 계층을 구성**하기 위해 사용되는 상혹
  - 자식 / 부모 클래스의 행동이 호환된다
  - 인터페이스 상속 (interface inheritance)
  - 슈퍼타입 인스턴스를 요구하는 모든 곳에서 서브타입의 인스턴스를 사용하기 위한 조건
    - 서브타입 퍼블릭 인터페이스  >= 슈퍼타입 퍼블릭 인스턴스
- 대체 가능성 (substitutability) : 부모 클래스가 사용되는 모든 문맥에서 자식을 사용할 수 있어야함

## 04 리스코프 치환 원칙

- 상속 관계로 연결한 두 클래스가 서브타이핑 관계를 만족 시키기 위한 조건 :
  - T에 의해 정의된 모든 프로그램 P에서 T가 S로 치환될 때, P의 동작이 변하지 않으면 S는 T의 서브타입
- 클라이언트가 부모/자식 차이점을 인지 못함 => 행동 호환성 만족
  - ex. 만족 못하는 예 : Stack + Vector. Vector에 대해 기대하는 행동을 Stack에서는 기대할 수 없음
    - 상속으로 Stack에는 포함돼서는 안 되는 Vector의 퍼블릭 인터페이스가 Stack의 퍼블릭 인터페이스에 포함됨
- ex. Rectangle(부모)와 Square(자식) - 서브클래싱 관계

### 클라이언트와 대체 가능성

- 위 예 : Square가 Rectangle를 대체할 수 없는 이유 = 클라이언트 입장에서 둘은 다름
- 리스코프 치환 원칙의 결론 : 클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다
  - 문맥과 대체 가능성을 결정하는 것은 클라이언트 이다

### is-a 관계 다시 살펴보기

- 상속관계는 클라이언트 입장에서 is-a 일 때만 is-a 관계다
- is-a 관계가 객체지향에서 중요한 점은 객체의 행동을 강조
  - 이름, 속성 > 행동

### 리스코프 치환 원칙은 유연한 설계의 기반이다

- 새로운 자식 클래스를 추가하더라도 클라이언트 입장에서 동일하게 행동 -> 클라이언트 수정 없이 상속 계층 확장 가능
- ex. DiscountPolicy 설계는 3가지 원칙 적용한 예
  1. 의존성 역전 원칙 (dependency inversion principle)  - 구체 클래스들 (Movie, OverlappedDiscountPolicy) 이 모두 추상 클래스 (DiscountPolicy)에게 의존함
  2. 리스코프 치환 원칙- 클라이언트 (Movie) 관점에서 부모 (DiscountPolicy) 대신 자식 (OverlappedDiscountPolicy)와 협력하더라도 문제가 없다
  3. 개방-폐쇄 원칙 (open close principle) - 새로운 기능 추가를 위해 부모 (DiscountPolicy)의 자식 클래스(OverlappedDiscountPolicy)를 추가해도 클라이언트 (Movie)에게 영향 없음
- 리스코프 치환 원칙 위반 == 잠재적인 개방-폐쇄 원칙 위반

### 타입 계층과 리스코프 치환 원칙

- 클래스 상속은 타입 계층 구현의 다양한 방법 중 하나일 뿐
  - 핵심은 구현 방법과 무관하게 클라이언트의 관점에서 슈퍼타입에 대해 기대하는 모든 것이 서브타입에 적용돼야 한다

## 05 계약에 의한 설계와 서브타이핑

- 계약에 의한 설계 (Design By Contract, DBC) : 클라/서버 사이의 협력을 *의무 (obligation)*과 *이익 (benefit)*으로 구성된 계약의 관점에서 표현 설계
  - 사전조건 (precondition), 사후조건 (postcondition), 클래스 불변식 (class invariant)를 만족 시켜야함

> 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 '계약'을 준수해야 된다
>
> 계약 : 서브타입이 그것의 슈퍼타입을 대체할 수 있어야 하고 클라이언트는 차이점을 인식하지 못함

- ex. DBC - Movie, DiscountPolicy
  - 사전조건 : 
    1. calculateDiscountAmoount메서드가 클라이언트가 전달하는 screening이 null이 아니다
    2. 영화 시작 시간이 아직 지나지 않았다
  - 사후조건:
    - calculateDiscountAmount 메서드의 반환값은 항상 null이 아니여야 함
    - 반환 값 > 0
  - 조건 들을 실제 DiscoutPolicy에 확인하는 메서드로 추가
  - AmountDiscountPolicy, PercentdiscountPolicy, OverlappedDiscountPolicy는 Movie와 DiscountPolicy 사이에 체결된 계약을 그대로 물려받음 -> DiscountPolicy를 대체할 수 있음 -> 서브타이핑 관계임

### 서브타입의 계약

- 자식 클래스가 부모 클래스의 메서드를 오버라이딩해서 사전조건 추가 가능
  - 클라이언트는 부모의 사전조건들 밖에 모름 -> 자식으로 대체 불가

> 서브타입에 더 강력한 사전조건을 정의할 수 없음 -> 최초로 보는 것은 슈퍼타입의 사전조건
>
> 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있음
>
> 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다
>
> 서브타입에 더 약한 사후조건을 정의할 수 없다 -> 최종으로 나오는건 서브타입의 사후조건

- 계약에 의한 설계는 클라이언트 관점에서 대체 가능성을 계약으로 설명할 수 있다는 사실을 잘 보여준다