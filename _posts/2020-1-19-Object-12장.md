---
layout: post
title: 12 다형성
---

- 상속의 목적은 코드 재사용이 아니다
  - 타입 계층을 구조화하기 위한 것

## 01 다형성

- 다형성 (Polymorphism) : 하나의 추사 인터페이스에 대해 코드를 작성 -> 이 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력
  - 여러 타입을 대상으로 동작할 수 있는 코드
- **다형성 (Polymorphism)**
  - **유니버설 (Universal)**
    - **매개변수 (Parametric)**
    - **포함 (Inclusion)/ 서브타입(subtype)** : 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라진다
      - 제일 흔함 - 전제 조건이 자식 클래스가 부모 클래스의 서브타입
      - 상속이 클래스들을 계층으로 쌓아 올린 후 상황에 맞게 메서드 선택
        - 메시지를 수신하면 상속 계층 내에서 실행할 메서드를 탐색함
  - **임시 (Ad Hoc)**
    - **오버로딩 (Overloading)** : 하나의 클래스 안에 동일한 이름의 메서드 존재
    - **강제 (Coercion) :** 언어가 지원하는 자동 타입 변환 / 직접 구현한 타입 변환을 이용해 동일한 연산자를 타양한  타입에 사용
    - 함께 사용하면 어떤 메서드가 호출될 지 모호해짐

## 02 상속의 양면성

- 객체지향 패러다임의 근간 : 데이터와 행동을 객체라고 불리는 하나의 실행 단위로 통합 - 상속도 마찬가지
  -  데이터 관점의 상속 : 부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함
  - 행동 관점의 상속 :  부모가 정의한 일부 메서드도 자동으로 자식 클래스에 포함
- 상속은 코드 재사용을 하기 위해 사용 x  - 구성 개념들을 기반으로 다형성이 가능한 타입 계층 구성
- 상속 메커니즘 개념
  - 업캐스팅
  - 동적 메서드 탐색
  - 동적 바인딩
  - self 참조
  - super 참조

### 상속을 사용한 강의 평가

#### Lecture 클래스 살펴보기

- Lecture(부모)과 GradedLecture(자식)은 evaluate이라는 시그니처가 동일한 메서드가 있지만 -> 자식이 우선 순위
  - 메서드 오버라이딩
- 이름은 같지만 시그니처가 다르면 메서드 대체가 일어나지 않음
- 상속을 사용하면 새로운 기능을 쉽고 빠르게 추가할 수 있지만 -> 코드 재사용 목적으로는 사용하면 안됨

### 데이터 관점의 상속

- 자녀는 자신이 선언한 인스턴스 변수뿐만 아니라 부모가 선언한 인스턴스 변수도 함께 포함됨
- 상속 관점에서 자식 클래스 안에 부모 클래스의 인스턴스가 포함되는 것으로 생각
  - 자식 -> 부모 클래스 인스턴스로 접근하는 링크가 존재한다고 생각해도 무방

### 행동 관점의 상속

- 데이터 관점 상속 : (자식 클래스 (부모 클래스))
- 행동 관점 상속 : 부모 클래스가 정의한 일부 메서드 -> 자식 클래스 포함
- 부모 클래스의 모든 퍼블릭 메서드는 자식 퍼블릭 인터페이스에 포함
  - 외부 객체가 부모 클래스의 인스턴스를 전송할 수 있는 모든 메시지는 자식 클래스의 인스턴스에게 전송 가능
  - 부모 인터페이스가 자식의 인터페이스에 합쳐진다 -> 실제 합침/복사는 x
    - 자식 클래스에 정의 되지 않은 메서드를 부모 클래스에서 **탐색함**
- 객체의 경우 서로 다른 상태를 저장하기 위해서는 독립적인 메모리를 할당 받아야함 -> 메서드는 주소 포인터만 공유
- 자식 클래스가 부모 클래스에 정의된 머세드를 실행하는 방법
  - 메시지 수신한 객체가 class 포인터로 자신의 클래스에 메서드 존재 확인
  - 없으면 부모 클래스 포인터 따라 탐색
    - 탐색하기 때문에 복사본을 가지고 있는 것처럼 보임 -> 최상위 부모까지 검색 가능

## 03 업캐스팅과 동적 바인딩

### 같은 메시지, 다른 메서드

- 업캐스팅 + 동적 바인딩을 통해 코드 안에서 선언된 참조 타입과 무관하게 실제로 메시지 수신하는 객체의 타입에 따라 실행 가능

> 업캐스팅  : 부모 타입으로 선언된 변수에 자식 클래스 인스턴스 할당
>
> 동적 바인딩 : 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드 결정

- *동일한* 수신자에게 *동일한* 메시지를 전송해서 *동일한* 코드를 이용해 **다른 메서드**를 실행 가능

### 업캐스팅

- 상속을 통해 부모 클래스의 퍼블릭 인터페이스를 자식 인터페이스에 합침
  - 부모에게 전송할 수 있는 메시지를 자식 클래스의 인스턴스에게 전송 가능
- 이런 특성 활용 - 대입문, 메서드의 파라미터 타입
  - 부모 클래스 변수 타입에 자식 클래스 인스턴스 대입 가능
    - 컴파일러 입장에서 제약없이 부모 클래스와 협력 가능한 클라는 자식과도 가능
  - 다운 캐스팅 - 부모 클래스 인스턴스를 자식 클래스 타입으로 변환

### 동적 바인딩

- 메서드 실행 방법은 **메시지 전송**
- 함수 호출 vs 메시지 전송
  - 함수 호출 : 컴파일타임 결정 - 정적 바인딩, 초기 바인딩, 컴파일타임 바인딩
  - 객체지향 (메시지 전송) : 런타임 결정 - 동적 바인딩, 지연 바인딩
- 객체지향 언어에서 업캐스팅과 동적 바인딩을 통해 부모 클래스 참조에 대한 메시지를 자녀 클래스의 메서드 호출로 변환가능

## 04 동적 메서드 탐색과 다형성

- 실행할 메서드 선택 기준
  - 메시지 수신한 객체에 적합한 메서드가 있는지 검색
    - 존재하면 탐색 종료
  - 메서드를 찾지 못하면 부모 클래스에서 탐색 계속
    - 찾을 때 까지 상속 계층을 올라간다
  - 최상위 클래스에 이르렀을 때 메서드를 발견하면 예외 발생 -> 탐색 중단
- 중요한 변수 - self 참조 (self reference)
  - 객체가 메시지 수신하면 컴파일러는 self 참조라는 임시 변수 자동 생성
    - 수신한 객체를 가르킨다 -> 메서드 탐색이 끝나면 소멸
- 메서드 탐색 순서 자식 -> 부모
- 동적 메서드 탐색 원리
  - 자동적인 메시지 위임 : 자식 클래스가 자신이 이해할 수 없는 메시지는 부모
  - 메서드 탐색을 위한 동적인 문맥 : 메시지 수신했을 때 실제로 어떤 메서드를 실행할지 컴파일 시점 아닌 실행 시점 결정
    - 메서드 탐색 경로는 self 참조 이용
    - 타입에 따라 메스드 실행 시점에서 동적으로 문맥 결정

### 자동적인 메시지 위임

- 동적 메서드 탐색 입장에서 메시지를 수신한 객체가 이해하지 못하는 메시지 -> 부모 클래스에게 넘김
  - 자동 위임
- 상속이 아니더라도 메시지 위임 가능
  - 루비 (모듈), 스칼라 (트레이트), 스위프트 (프로토콜) + (확장)
- 자식이 어떤 메서드를 구현하고 있나에 따라 부모의 구현된 메서드의 운명 결정 -> 자식이 먼저 실행

#### 메서드 오버라이딩

- self 참조가 가르키는 객체의 클래스 부터 시작 -> 부모로
  - 부모의 메서드를 감추는 것 처럼 보이게함

#### 메서드 오버로딩

- 동일한 이름의 메서드, 하지만 다른 시그니처
  - 상속 계층 사이에도 공존 가능
    - name hiding : C++은 계층 사이 오버로딩 지원 x 

### 동적인 문맥

- 메시지를 수신한 객체가 무엇이냐에 따라 메서드 탐색이 동적으로 바뀐다
  - 문맥 결정 - self 참조
- self 참조롤 동적 문맥을 결정하기 때문에 어떤 메서드가 실행될지 예상 어려움
  - ex. self send - 메서드 호출 x, 현재 객체에게 메시지 전송
    1. 인스턴스가 메시지를 수신하면 self 참조가 인스턴스를 가리키고 a 메서드 탐색 시작
    2. a 메서드를 찾음, a 메서드 안에 b메서드가 있음
    3. b를 가리키고 있는 객체에게 메시지 전송, 결국 self -> **항상 탐색은 처음 self 참조 부터**
  - 중간에 숨겨저 있는 메서드 오버라이딩을 만나면 이해하기 어려운 코드가 만들어짐

### 이해할 수 없는 메시지

- 상속 계층의 정상까지 왔는데 모르는 메시지면?

#### 정적 타입 언어와 이해할 수 없는 메시지

- 정적 타입은 컴파일 에러 발생

#### 동적 타입 언어와 이해할 수 없는 메시지

- 컴파일 단계가 없기 대문에 실제로 코드를 실행하기 전까지 처리 가능 여부를 모른다
  - 처리할 수 없는 메시지를 발견하면 self 참조가 가리키는 객체에게 메시지 이해를 못하는 *메시지*를 보냄
  - 단지 객체가 메시지를 처리할 수 있다고 믿고 전송함
- 동적 타입 언어는 이해할 수 없는 메시지를 처리할 수 있는 능력이 있음
  - 메시지가 선언된 인터페이스와 메서드 구현을 분리 가능 -> 메시지 전송자는 자신이 원하는 메시지를 전송하고 수신자는 스스로 판단에 따라 처리
    - 순수 객체지향의 이상에 가까움 -> 단점 : 디버깅이 어려움

> 이해할 수 없는 메시지와 도메인-특화 언어 (Domain Specific Language)
>
> 메타 프로그래밍 영역에서 유용함 - 정적 타입 언어보다 더 쉽고 강력한 도메인 특화 언어 개발 가능
>
> 	- 이런 방식을 동적 리셉션 (dynamic reception) 이라고 부름

### self 대 super

- self 참조의 가장 큰 특징 - 동적
  - super도 언급할 만한 가치 있음
- 부모의 **메서들 호출**하는 것이 아니라 super 참조를 사용해서 **'메시지를 전송'한다**
- 바로 조상이 부모 클래스가 아니더라도 조상을 찾아 탐색함
- super send : 부모의 인스턴스에게 메시지를 전송하는 것 처럼 보여서
- self 전송은 어떤 클래스에게 메시지 탐색이 시작될지 모름 - super은 항상 해당 클래스의 부모

## 05 상속 대 위임

- 다형성은 self 참조가 가리키는 현재 객체에게 메시지를 전송하는 특성
  - 같은 타입의 객체에게 동일한 메시지를 전송해도 결국 self 참조 객체에게 가서 문맥이 달라짐

### 위임가 self 참조

- 부모가 가진 self 링크도 결국 메시지를 수신한 객체에게 돌아감
  - 자식이나 부목나 동일한 self 참조를 공유함
- 위임 (delegation) - 자신이 수신한 메시지를 다른 객체에게 동일하게 전달에서 처리 요청
  - **현재 실행 문맥을 가리키는 self 참조를 인자로 전달함**
  - self 참조를 하지 않는 포워딩과 차이점

> 위임 vs 포워딩
>
> 위임 : 요청 받은 최최의 객체가 다시 메시지 전송은 필요 없고 순수히 코드만 재사용 - 요청 처리 대 self 참조
>
> ​	- 클래스를 이용한 상속 관계를 객체 사이의 합성 관계로 대체해서 **다형성 구현**
>
> 포워딩 : 참조 전달 x

- 위임은 동적인 연결 관계를 이용해서 상속 구현
  - 상속의 매력은 이런 번잡한 과정을 자동 처리

### 프로토타입 기반의 객체지향 언어

- 객체가 아니더라도 상속을 흉내 낼 수 있다 - 위임 사용

  - 프로토타입

- ex. JavaScript

  - 메시지를 수신한 객체의 prototype 안에 응답할 메서드 존재 검사
  - 없으면 prototype이 가리키는 객체를 다라 메시지 처리 자동 위임

- 객체지향을 객체를 지향한다

  - 클래스는 객체를 편리하게 정의하고 생성하기 위한 하나의 프로그램 구성
    - 목적을 이루기 위해 중요한 것은 메시지와 협력
    - 클래스 없이도 협력 관계, 상속 없이도 다형성 구현 가능

- 클래스 기반/객체 기반의 상속은 기본 개념과 메커니즘 공유

  