---
layout: post
title: 11. 합성과 유연한 설계
---

- 상속과 합성은 널리 사용되는 재사용 기법
- 상속 : 부모 클래스와 자녀 클래스를 연결해서 부모 코드 재사용
  - 컴파일타임
  - is-a relationship
  - 부모의 이름만 추가해서 쉽게 사용가능
    - 하지만 부모의 내부 구현을 상세하게 알아야 하기 때문에 결합도 증가
  - 정적인 관계 -> 코드 작성 시점에서 변경 불가
- 합성 : 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 코드 재사용
  - 런타임
  - has-a relationship
  - 의존하는 객체의 내부 구현에 의존하는 것이 아니라 **퍼블릭 인터페이스**에 의존하기 때문에 안정적인 코드
  - 동적인 관계 -> 실행 시점에 동적으로 변경 가능 -> 변경하기 쉽고 유연한 설계

> 서브클래싱 (상속)은 white-box reuse : 부모의 클래스 내부가 자식 클래스에 공개 되어야 함

## 01 상속을 합성으로 변경하기

- 상속을 남용했을 대 발생하는 문제 3가지
  - 불필요한 인터페이스 상속 문제 : 자식 클래스가 부모 클래스의 부적합한 오퍼레이션을 상속 받음
  - 메서드 오버라이딩의 오작용 문제 : 자식 클래스가 부모 클래스를 오버라이딩 할 때 부모 클래스의 호출 방법에 영향을 받는 문제
  - 부모 클래스와 자식 클래스 동시 수정 문제 : 부모 클래스와 자식 클래스 사이의 개념적인 결합으로 인해 부모 클래스 변경 시 자식 클래스도 함께 변경되어야 하는 문제
- 상속->합성으로 바꾸면 해결됨

### 불필요한 인터페이스 상속 문제 : java.util.Properties와 java.util.Stack

- Hashtable을 Properties의 인스턴스 변수로 추가하면 합성 관계로 변함
  - 불필요한 Hashtable의 오퍼레이션들이 Properties의 퍼블릭 인터페이스를 오염시키지 않는다 -> 클라이언트는 Properties가 정의한 오퍼레이션만 사용할 수 있다
  - Properties는 Hashtable의 내부 구현에 대해 모름
  - 클라이언트가 Properties를 잘못 사용할 수 있는 가능성을 제거함

### 메서드 오버라이딩의 오작용 문제 : InstrumentedHashSet

- InstrumentedHashSet은 HashSet이 제공하는 퍼블릭 인터페이스 그대로 제공해야함
- HashSet과의 구현 결합도를 제거하면서 퍼블릭 인터페이스를 그대로 제공 받는 방법?
  - 인터페스를 implements하고 실제 오퍼레이션은 실체화된 Set을 통해서 구현
  - 포워딩 (forwarding) : 합성한 오퍼레이션을 오버라이딩한 인스턴스 메서드에서 내부의 실체화된 인스턴스의 동일한 메서드 호출을 그대로 전달함

### 부모 클래스와 자식 클래스의 동시 수정 문제 : PersonalPlaylist

- 합성을 통해 가수별 노래 목록을 유지하기 위해 Playlist와 PersonalPlaylist를 함께 수정해야 하는 문제는 해결되지 않는다
  - 하지만 상속보다는 더 좋음 -> 향후 Playlist 내부 구현을 변경하더라도 PersonalPlaylist 내부로 캡슐화 가능

> 몽키 패치 (Monkey Patch) : 현재 실행 중인 환경에서만 영향을 미치도록 지역적으로 코드를 수정하거나 확장하는 방법
>
> ​	- Open Class (Ruby), Extension Method (C#), Java (AOP로 해결)
>
> ex. Playlist를 수정할 권한이 없더라도 몽키패치가 허용되면 Playlist에 직접 remove 메서드를 추가하는 것이 가능

- 합성은 안정성과 유연성을 제공함

## 02 상속으로 인한 조합의 폭발적인 증가

- 상속으로 인해 결합도가 높아짐 -> 수정할 때 필요한 작업 양이 과도하게 늘어남
  - 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야함
  - 단일 상속만 지원하는 언어에서는 오히려 중복 코드의 양이 늘어날 수도 있다

### 기본 정책과 부가 정책 조합하기

- 부가정책을 추가하는 요구사항이 생김
  - 기본정책의 계산 결과에 적용된다
  - 선택적으로 적용할 수 있다
  - 조합 가능하다
  - 부가 정책은 임의의 순서로 적용 가능하다

### 상속을 이용해서 기본 정책 구현하기

- Phone 추상 클래스를 root로 삼아 상속 계층 사용
  - RegularPhone + NightlyDiscountPhone이 자녀

### 기본 정책에 세금 정책 조합하기

- 일반 요금제에 세금 정책 조합하기
  - TaxableRegularPhone 추가
    - RegularPhone을 상속 받아 super을 호출해서 calculateFee에 메시지 보내서 요금 반환 -> 결합도 증가
      - 해결 방법 : 자식 클래스가 부모 클래스의 메서드를 호출 하지 않게 부모 클래스에서 **추상 메서드** 제공
- 상속을 하면 부모가 추상화 메서드를 추가할 때 자식 클래스들이 추상 메서드를 오버라이딩해야함 -> 합성은 문제없음
  - 많은 자식 클래스가 존재하면 번거로움

> 개방-폐쇄 원칙을 만족하는 설계를 만들 수 있는 한 가지 방법은 부모 클래스에 새로운 추상 메서드를 추가하고 부모 클래스의 다른 메서드에서 해당 메서드 호출
>
> 훅 메서드 (hook method) : 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도로 메서드를 추가했지만 편의를 위해 기본 구현을 제공하는 메서드
>
> 	- ex. afterCalculated

- Phone, RegularPhone, NightlyDiscountPhone, **TaxableRegularPhone, TaxableNightlyDiscountPhone**
  - 둘 사이 중복 코드 발생

### 기본 정책에 기본 요금 할인 정책 조합하기

- 기본 요금 할인 정책 추가 - RateDiscountableRegularPhone 추가
  - RateDiscountableRegularPhone <-> RateDiscountableNightlyDiscountPhone 사이에 중복 코드 추가

### 중복 코드의 덫에 걸리다

- 부가 정책은 자유롭게 조합할 수 있어야 하고 적용되는 순서 역시 임의로 결정할 수 있어야 한다
- 지금 구조로는 조합의 경우의 수 만큼 클래스를 만들어야 한다
  - 클래스 폭발 (class explosion) / 조합의 폭발 (combinational explosion)가 발생한다
  - 클래스 추가 + 수정 때마다 발생
- 상속 포기해야함

## 03 합성 관계로 변경하기

- 상속 관계는 컴파일타임에 결정 + 고정 -> 코드를 실행하는 중간에 변경 불가
  - 여러 조합을 만들기에는 가능한 모든 조합을 클래스 별로 추가
- 컴파일타임과 런타임 의존성이 멀수록 설계가 유연해짐
  - 상속은 컴파일/런타임 의존성을 동일하게 만든다
- 합성을 사용하면 구현 시점에 정책들의 관계를 고정 시킬 필요가 없음
  - 합성으로는 조합을 구성하는 요소들을 개별 클래스로 구현하고 실행 시점에 인스턴스를 조립함 -> 컴파일 의존성에 속박되지 않고 다양한 방식의 런타임 의존성을 구성할 수 있다
- 컴파일/런타임 의존성이 멀어질 수록 설계의 복잡도가 상승함 -> 코드가 어려워진다
  - 설계는 유지보수를 위해 존재함 -> 따라 트레이드오프

### 기본 정책 합성하기

- 각 정책을 별도의 클래스로 구현
- Phone 내분에 RatePolicy에 대한 참조자가 존재 -> 합성
- Phone 생성 시 사용하고 싶은 정책을 생성해서 합성해주면 된다

### 부가 정책 적용하기

- 부가 정책은 합성 체이닝으로
  - 약간 재귀 함수 느낌으로 간다

### 새로운 정책 추가하기

- 클래스 하나만 추가하면 된다
  - 그냥 조합에 체이닝 하면 됨
- 코드 재사용을 위해서는 : 상속 < 합성

### 객체 합성이 클래스 상속보다 더 좋은 방법이다

- 상속은 코드 재사용을 위한 우아한 방법은 아니다
  - 그럼 언제 사용해야 하나? -> 먼저 구현 상속 / 인터페이스 상속을 구분해야함
    - 모든 단점은 **구현 상속**에 국한됨
- 믹스인 : 상속과 합성의 특성을 모두 보유하고 있음

## 04 믹스인

- 우리가 원하는 것은 코드를 재사용하면서 남득할 만한 결합도를 유지하는 것
- 합성이 상속과 같은 문제점을 초래하지 않는 이유 : 구체적인 구현이 아니라 추상적인 인터페이스에 의존함
- 믹스인 (mixin) : 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법
  - 컴파일 시점에 필요한 코드 조각을 조합하여 재사용
- 상속 vs 믹스인
  - 상속 목적 : 자식 클래를 부모 클래스와 동일한 개념적인 범주로 묶어 is-a 관계로 만듬
  - 믹스인 목적 : 말 그대로 코드를 다른 코드 안에 섞어 넣기
- 믹스인 : 코드 재사용에 특화된 방법 + **결합도 문제를 초래하지 않음**
- Flavors라는 언어에서 도입됨 -> CLOS (Common Lisp Object System) -> Scala traits

### 기본 정책 구현하기

- Scala 예제

### 트레이트로 부가 정책 구현하기

- 기본 정책 구현까지는 자바와 같음 -> 부가 정책 코드를 기본 정책 클래스에 넣을 때 두드러짐
- extends -> 상속 개념이 아니라 TaxablePolicy가 BasicRatePolicy나 BasicRatePolicy의 자손에 해당되는 경우에만 믹스인될 수 있다는 의미 (type)
  - 문맥 제한-> 제약을 코드로 표현 : 개발자 실수 막기
- 상속은 정적 / 믹스인은 동적
- scala에서 super은 동적으로 결정됨
  - super 호출 시점에 바인딩 됨
- 사실 mixin은 상속보다 합성에 더 가까움

### 부가 정책 트레이트 믹스인하기

- 스칼라는 트레이트를 다른 클래스나 트레이트에 믹스인할 수 있도록 extends + within 키워드를 제공한다
  - 트레이트 조합 (trait composition)
- 메시지를 전송 했을 때 어떤 메서드; 믹스인한 클래스, 트레이트를 선형화 (linearization)해서 실행될지 정함
  - class, trait (within), inheritence (extends)
- 편의하게 조합할 수 있음 -> 클래스 폭발 방지
  - 중복 코드 증가 방지

### 쌓을 수 있는 변경

-  믹스인은 특정한 클래스의 메서드를 재사용하고 기능을 확장하기 위해 사용돼 왔다
- 믹스인은 상속 계층 안에서 확장한 클래스보다 더 하위에 위치함
  - 추상 서프클래스 (abstract subclass)
- 믹스인을 사용하면 특정한 클래스에 대한 변경을 독립적으로 구현하고 필요할 때 추가 가능
  - stackable modification
- class vs trait
  - 클래스 super 호출 = 정적 vs 트레이트 super 호출 = 동적